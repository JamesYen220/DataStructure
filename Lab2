#include "FixedSP.h"
#include <iostream>
#include <vector>
#include <algorithm>    // std::next_permutation, std::sort
using namespace std;
#define V 5


int minDistance(int dist[], bool sptSet[])
{

    // Initialize min value
    int min = INF, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}


// Function that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[][V], int s)
{
    for(int i = 0; i < V; ++i){
        for(int j = 0; j < V; ++j){
            graph[s][j] = graph[j][s];
        }
    }
    int dist[V]; // The output array.  dist[i] will hold the shor       test
    // distance from src to i

    bool sptSet[V]; // sptSet[i] will be true if vertex i is included in shortest
    // path tree or shortest distance from src to i is finalized

    // Initialize all distances as INFINITE and stpSet[] as false
    for (int i = 0; i < V; i++)
        dist[i] = INF, sptSet[i] = false;


    // Distance of source vertex from itself is always 0
    dist[s] = 0;

    // Find shortest path for all vertices
    for (int count = 0; count < V - 1; count++) {
        // Pick the minimum distance vertex from the set of vertices not
        // yet processed. u is always equal to src in the first iteration.
        int u = minDistance(dist, sptSet);

        // Mark the picked vertex as processed
        sptSet[u] = true;

        // Update dist value of the adjacent vertices of the picked vertex.
        for (int v = 0; v < V; v++)

            // Update dist[v] only if is not in sptSet, there is an edge from
            // u to v, and total weight of path from src to  v through u is
            // smaller than current value of dist[v]
            if (!sptSet[v] && graph[u][v] && dist[u] != INF && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }
    for (int i=0; i<=V; i++){
        graph[s][i] = dist[i];
    }
}

// implementation of traveling Salesman Problem
int travllingSalesmanProblem(int graph[][V], int s,  vector<int> intermediates) {
    // store all vertex apart from source vertex
    vector<int> vertex;
    int m = intermediates.size();
    for (int i = 0; i <= V; i++)
        if (i != s)
            vertex.push_back(i);

    int k=s;
    //The shortest distance between the source node and the must-pass node
    for(int i=0; i<vertex.size(); i++) {
        dijkstra(graph, k);
         k=vertex[i];
    }


    // store minimum weight Hamiltonian Cycle.
    int min_path = INF;
    do {

        // store current Path weight(cost)
        int current_pathweight = 0;
        int mid_pathweight = 0;
        // compute current path weight
         k = s;
         int size = intermediates.size();
//        for (int i = 0; i < size; i++) {
//            int x = intermediates[i-1];
//            if(i == 0 || i == size-1) {
//                current_pathweight += graph[k][intermediates[i]];   //0->1  ,  2->0
//            }
//            else{
//                for (int mid = 0; mid < size-1; mid++) {
//                    int mvalue = intermediates[mid];
//                    mid_pathweight += graph[mvalue][intermediates[mid + 1]]; //1->2->3
//                }
//            }
//        }

//        for (int i = 0; i < size; i++) {
//            if (i !=0 && i != size-1) {
                for (int mid = 0; mid < size - 1; mid++) {
                    int mvalue = intermediates[mid];
                    mid_pathweight += graph[mvalue][intermediates[mid + 1]]; //1->2->3
                }
//            }
//        }
        for (int i = 0; i < size; i++) {
            if(i == 0 || i == size-1){
                current_pathweight += graph[k][intermediates[i]];   //0->1  ,  2->0
            }
        }
            current_pathweight += mid_pathweight;

        // update minimum
        min_path = min(min_path, current_pathweight);

    } while (
            next_permutation(intermediates.begin(), intermediates.end()));

    return min_path;
}


vector<int> FixedSP::getFixedPointShortestPath(int source, vector<int> intermediates)
{
    vector<int> path = {0,1,4,3,2,3,0};
    int graph[V][V];
    for(int i = 0; i < V; ++i){
        for(int j = 0; j < V; ++j){
            graph[i][j] = spmatrix[i][j];
        }
    }
    int s = source;
    cout << travllingSalesmanProblem(graph, s, intermediates) << endl;

//    cout<<intermediates.size()<<endl;
//    cout<<spmatrix.size()<<endl;
    // TODO

    return path;
}
